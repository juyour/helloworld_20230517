
# 1. Top
***
-> 시스템에서 실행 중인 프로세스의 실시간 모니터링을 제공하는 명령어 
- CPU, 메모리, 프로세스 ID 등의 정보를 표시
- 실행 중인 프로세스의 상태를 확인할 수 있습니다.

#### top 실행 전 옵션

  - 순간의 정보를 확인하려면 -b 옵션 추가(batch 모드)
  - -n : top 실행 주기 설정(반복 횟수)
  
#### top 실행 후 명령어

  - shift + p : CPU 사용률 내림차순
  - shit + m : 메모리 사용률 내림차순
  - shift + t : 프로세스가 돌아가고 있는 시간 순
  - k : kill. k 입력 후 PID 번호 작성. signal은 9
  - f : sort field 선택 화면 -> q 누르면 RES순으로 정렬
  - a : 메모리 사용량에 따라 정렬
  - b : Batch 모드로 작동
  - 1 : CPU Core별로 사용량 보여줌
  
  - ![top -b -n 1 실행 결과](https://github.com/juyour/helloworld_20230517/assets/76831215/a29f2a99-b676-4ad9-bdcd-77f3da6ef0a2)
  
  - 3:58 : 3시간 58분 전에 서버가 구동
  - load average : 현재 시스템이 얼마나 일을 하는지를 나타냄. 3개의 숫자는 1분, 5분, 15분 간의 평균 실행/대기 중인 프로세스의 수. CPU   코어수 보다 적으면 문제 없음
  - Tasks : 프로세스 개수
  - KiB Mem, Swap : 각 메모리의 사용량
  - PR : 실행 우선순위
  - VIRT, RES, SHR : 메모리 사용량 => 누수 check 가능  
  - S : 프로세스 상태(작업중, I/O 대기, 유휴 상태 등)

  #### VIRT, RES, SHR
   - 현재 프로세스가 사용하고 있는 메모리
   **VIRT**
    - 프로세스가 사용하고 있는 virtual memory의 전체 용량
    - 프로세스에 할당된 가상 메모리 전체
  
  ##### SWAP + RES
   **RES**
   - 현재 프로세스가 사용하고 있는 물리 메모리의 양
   - 실제로 메모리에 올려서 사용하고 있는 물리 메모리
   - 실제로 메모리를 쓰고 있는 RES가 핵심!
   **SHR**
   - 다른 프로세스와 공유하고 있는 shared memory의 양 
   - 예시로 라이브러리를 들 수 있음. 대부분의 리눅스 프로세스는 glibc라는 라이브러리를 참고하기에 이런 라이브러리를 공유 메모리에 올려서 사용
    
   **Memory Commit**
    
   - 프로세스가 커널에게 필요한 메모리를 요청하면 커널은 프로세스에 메모리 영역을 주고 실제로 할당은 하지 않지만 해당 영역을 프로세스에게 주었다는 것을 저장해둠
    
   - 이런 과정을 Memory commit이라 부름
    
   - 왜 커널은 프로세스의 메모리 요청에 따라 즉시 할당하지 않고 Memory Commit과 같은 기술을 사용해 요청을 지연시킬까?
     -> fork()와 같은 새로운 프로세스를 만들기 위한 콜을 처리해야 하기 때문
    
   - fork() 시스템 콜을 사용하면 커널은 실행중인 프로세스와 똑같은 프로세스를 하나 더 만들고, exec() 시스템 콜을 통해 다른 프로세스로 변함. 
   
   - COW(Copy-On-Write) 기법을 통해 복사된 메모리 영역에 실제 쓰기 작업이 발생한 후 실질적인 메모리 할당을 진행
    
   **프로세스 상태**
  
   - SHR 옆에 있는 S 항목으로 볼 수 있음
   - D : Uninterruptiable sleep. 디스크 혹은 네트워크 I/O를 대기
   - R : 실행 중(CPU 자원을 소모)
   - S : Sleeping 상태, 요청한 리소스를 즉시 사용 가능
   - T : Traced or Stopped. 보통의 시스템에서 자주 볼 수 없는 상태
   - Z : zombie. 부모 프로세스가 죽은 자식 프로세스
    
# 2. ps
***
  -> ps(process status)의 줄인말로 ps 명령어는 현재 실행중인 프로세스 목록과 상태를 보여줍니다.

  - e: 현재 사용자뿐만 아니라 다른 사용자들이 구동시킨 모든 프로세스를 보여줍니다. (즉, -e 옵션이 없다면 ps 명령어는 현재 사용자(Shell)이 실행 중인 프로세스만 보여줍니다.)
  - f: 보다 상세한 정보를 보여줍니다. (Full format)
  - l: -f 보다 더 상세한 정보를 보여줍니다. (Long format)
  
  **ps -efl 명령어를 통해 출력되는 결과의 각 필드의 의미**
    
   - F: 프로세스 플래그.
   
     - 4: used super-user privileges
     - 1: forked but didn't exec
     - 5: 4 & 1 플래그에 모두 해당하는 경우
     - 0: 어떤 플래그에도 해당하지 않는 경우
     
   - S: 프로세스의 현재 상태
   
     - R: 실행 중 혹은 실행될 수 있는 상태
     - S: 대기 상태 (약 20초 이상)
     - I: 대기 상태 (약 20초 이하)
     - T: 작업 제어에 의해 정지된 상태
     - D: 디스크 관련 대기 상태
     - P: 페이지 관련 대기 상태
     - X: 메모리 확보를 위한 대기 상태
     - (>): 인위적으로 우선 순위가 높아진 상태
     - Z: 좀비 프로세스
     
   - UID: 프로세스를 실행시킨 사용자 ID
   
   - PID: 프로세스에 부여된 ID
   
   - PPID: 프로세스의 부모 프로세스 ID (Parent Process ID)
   
   - C: CPU 사용량(%)
   
   - PRI: 프로세스 우선순위
   
   - NI: 프로세스의 CPU 자원 사용 우선순위 (Nice)
    
   - ADDR: 프로세스의 메모리 주소
   
   - SZ: 가상 메모리 사용량
   
   - STIME: 프로세스 시작 시간
   
   - TTY: 프로세스가 실행된 터미널의 종류와 번호
   
   - TIME: 프로세스에 의해 사용된 CPU 시간
   
   - CMD: 실행된 프로세스의 이름 혹은 실행된 명령

# 3. Jobs
***

  -> 리눅스 셸(shell)에서 백그라운드(background)에서 실행 중인 작업 목록을 표시하는 명령어입니다. 
  
  -> 셸에서 작업을 백그라운드로 실행하면 해당 작업은 현재 셸 세션과 독립적으로 실행되며, 화면에 표시되지 않습니다. 
  
  -> jobs 명령어를 사용하면 백그라운드에서 실행 중인 작업의 상태를 확인할 수 있습니다.

  - 작업 ID (Job ID): 백그라운드 작업의 고유 식별자입니다.
  - 작업 상태 (Job State): 작업이 실행 중인지 (running), 중지된 상태인지 (stopped), 백그라운드로 실행된 상태인지 (background) 등을 나타냅니다.
  - 작업 명령어 (Job Command): 백그라운드 작업으로 실행된 명령어나 프로그램의 이름입니다.
  - 작업 ID (Job ID): 작업을 식별하기 위한 고유한 숫자입니다. [숫자] 형식으로 표시됩니다.
  - 작업 상태 (Job State): 작업의 현재 상태를 나타냅니다. 주요 상태는 다음과 같습니다:
  
    - Running: 작업이 현재 실행 중인 상태입니다.
    
    - Stopped: 작업이 중지된 상태입니다. 
    
    - 예를 들어, Ctrl+Z를 눌러 작업을 중지한 경우 해당 상태가 됩니다.
    
    - Done: 작업이 완료된 상태입니다.
    
    - 작업 명령어 (Job Command): 백그라운드에서 실행 중인 작업에 대한 명령어나 프로그램의 이름입니다.
    
    - jobs 명령어는 주로 백그라운드에서 실행 중인 작업들의 상태를 확인하고 관리하는 데 사용됩니다. 
    
    - 예를 들어, 백그라운드에서 실행 중인 작업을 중지하거나 재개하고자 할 때 fg (foreground) 또는 bg (background) 명령어와 함께 사용될 수 있습니다.

      - fg 명령어: 백그라운드 작업을 포그라운드로 가져와 실행합니다. 
      - 예를 들어, fg %1과 같이 사용하여 작업 ID 1인 작업을 포그라운드로 가져올 수 있습니다.
      - bg 명령어: 중지된 백그라운드 작업을 다시 실행합니다. 
      - 예를 들어, bg %2와 같이 사용하여 작업 ID 2인 작업을 다시 실행할 수 있습니다.
      - 또한, kill 명령어와 함께 사용하여 백그라운드 작업을 강제로 종료할 수도 있습니다. 
      - kill %3과 같이 사용하여 작업 ID 3인 작업을 종료할 수 있습니다.

  - jobs 명령어는 주로 리눅스의 셸 환경에서 사용되며, bash, zsh, ksh 등의 다양한 셸에서 지원됩니다. 
  - 다른 셸에서는 유사한 기능을 제공하는 다른 명령어가 있을 수 있습니다.

  - jobs 명령어를 사용하여 현재 실행 중인 작업의 상태를 확인할 수 있습니다. 
  - 셸에서 백그라운드에서 실행 중인 작업이 없다면 아무런 결과도 출력되지 않습니다.
  - 들어, 다음은 백그라운드에서 실행 중인 작업의 목록을 표시하는 예입니다:
  
        $ sleep 10 &
        [1] 1234
        $ ls -l &
        [2] 5678
        $ jobs
        [1]-  Running                 sleep 10 &
        [2]+  Running                 ls -l &
   
  - 위의 예제에서 sleep 10과 ls -l 명령어는 백그라운드에서 실행되고 있습니다. 
  - jobs 명령어를 사용하여 현재 실행 중인 작업의 상태를 확인할 수 있습니다. 
  - [1]과 [2]는 작업 ID를 나타내며, Running은 작업의 상태를 나타냅니다.
    
# 4. kill
***
-> kill 명령어는 리눅스에서 프로세스를 종료시키는 명령어입니다. 
-> 이 명령어는 프로세스에 시그널(signal)을 보내어 프로세스의 동작을 제어하거나 종료할 수 있습니다.

- kill 명령어의 일반적인 사용 형식은 다음과 같습니다:


      kill [옵션] [프로세스ID 또는 작업ID]

- 옵션: kill 명령어에 적용되는 추가 옵션을 지정합니다. 
- 일반적으로 가장 많이 사용되는 옵션은 -9이며, 이는 강제 종료를 의미하는 시그널을 보내는 옵션입니다. (SIGKILL 시그널)
- 프로세스ID 또는 작업ID: 종료하려는 프로세스의 고유 식별자인 프로세스ID(PID) 또는 jobs 명령어로 확인할 수 있는 작업ID(Job ID)를 지정합니다.
- kill 명령어는 다양한 시그널을 사용하여 프로세스에 영향을 줄 수 있습니다. 
- 명령어를 실행할 때 별도의 시그널을 지정하지 않으면 기본적으로 SIGTERM 시그널을 보내어 프로세스를 종료시킵니다. 
- 그러나 -9 옵션을 사용하여 SIGKILL 시그널을 보내면 프로세스를 강제로 종료할 수 있습니다. 
- 이는 일반적으로 가장 강력한 종료 방법으로, 프로세스가 처리 중이던 작업을 완료하지 않고 바로 종료됩니다.
- 예를 들어, 다음은 kill 명령어를 사용하여 프로세스를 종료하는 예입니다:


      yaml
      Copy code
      $ ps aux | grep myprocess
      user     1234  0.0  0.0   1234   5678 pts/0    S+   10:00   0:00 myprocess
      $ kill 1234
   
- 위의 예제에서 ps 명령어와 grep 명령어를 사용하여 myprocess라는 프로세스의 PID를 확인합니다. 
- 그런 다음 kill 명령어를 사용하여 해당 PID에 대한 SIGTERM 시그널을 보내어 프로세스를 종료합니다.

- kill 명령어는 다양한 시그널을 사용하여 프로세스를 제어할 수 있습니다. 
- 일반적으로 사용되는 몇 가지 시그널은 다음과 같습니다:

    - SIGTERM (기본 시그널): 이 시그널은 프로세스에 정상적인 종료 신호를 보냅니다. 
    - kill 명령어를 실행할 때 별도의 시그널을 지정하지 않으면 기본적으로 SIGTERM 시그널이 사용됩니다. 프로세스는 이 시그널을 수신하면 정리 작업을 수행한 후 종료됩니다.
    - SIGKILL (-9 옵션): 이 시그널은 프로세스를 강제로 종료시키는 시그널로, 프로세스가 처리 중이던 작업을 완료하지 않고 즉시 종료됩니다. 
    - kill -9 명령어로 사용됩니다. 주의할 점은 SIGKILL 시그널은 프로세스에 어떠한 정리 작업도 허용하지 않기 때문에, 데이터 손실이 발생할 수 있습니다.
    - SIGINT (Ctrl+C): 이 시그널은 사용자가 프로세스에 대해 인터럽트 신호를 보내는 경우에 사용됩니다. 
    - 일반적으로 터미널에서 실행 중인 프로세스를 중지하고자 할 때 사용합니다.
    - SIGHUP: 이 시그널은 프로세스에 터미널 연결이 끊겼음을 알리는 신호입니다. 
    - 일반적으로 백그라운드에서 실행 중인 프로세스에게 재시작을 알리는 목적으로 사용됩니다.
    - 기타 시그널: SIGSTOP (일시 중지), SIGCONT (다시 시작), SIGQUIT (종료 및 코어 덤프 생성) 등 다른 시그널들도 kill 명령어로 사용될 수 있습니다.
    - kill 명령어의 사용 예시는 다음과 같습니다:


          shell
          Copy code
          $ kill 1234  # PID가 1234인 프로세스에 SIGTERM을 보냄
          $ kill -9 5678  # PID가 5678인 프로세스에 SIGKILL을 보냄
          $ kill -SIGINT 9012  # PID가 9012인 프로세스에 SIGINT(Ctrl+C)을 보냄
          $ kill -SIGHUP 3456  # PID가 3456인 프로세스에 SIGHUP을 보냄

- 프로세스 그룹에 시그널 보내기:

      shell
      Copy code
      $ kill -SIGTERM -1234

- 위의 예시에서 -1234는 프로세스 그룹의 ID를 나타냅니다. 
- 이 명령은 프로세스 그룹에 SIGTERM 시그널을 보내서 그룹 내의 모든 프로세스를 종료시킵니다.

- 프로세스 이름으로 프로세스 종료하기:


      ruby
      Copy code
      $ pkill firefox

- 위의 예시에서 firefox는 종료하려는 프로세스의 이름입니다. 
- pkill 명령어는 지정된 이름과 일치하는 모든 프로세스에 SIGTERM 시그널을 보내어 종료시킵니다.

- 사용자에 의해 실행된 모든 프로세스 종료하기:


      ruby
      Copy code
      $ pkill -u username

- 위의 예시에서 username은 종료하려는 사용자의 이름입니다. 
- pkill 명령어는 해당 사용자에 의해 실행된 모든 프로세스에 SIGTERM 시그널을 보내어 종료시킵니다.

- 작업 ID로 작업 종료하기:


      perl
      Copy code
      $ kill %1

- 위의 예시에서 %1은 작업 ID를 나타냅니다. 
- kill 명령어를 사용하여 작업 ID에 해당하는 작업을 종료시킬 수 있습니다. 
- 작업 ID는 jobs 명령어로 확인할 수 있습니다.

- kill 명령어는 강력한 도구이므로 조심해서 사용해야 합니다. 
- 특히 SIGKILL 시그널을 사용하는 -9 옵션은 프로세스를 강제 종료시키기 때문에, 데이터 손실이 발생할 수 있습니다. 
- 가능한한 먼저 정상적인 종료를 시도하고, 필요한 경우에만 SIGKILL 시그널을 사용해야 합니다.



